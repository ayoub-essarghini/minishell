heredoc> #include "parsing.h"
heredoc> heredoc> t_envs *ft_lstlast2(t_envs *lst)
heredoc> {
heredoc>     if (!lst)
heredoc>         return (NULL);
heredoc>     while (lst->next != NULL)
heredoc>     {
heredoc>         lst = lst->next;
heredoc>     }
heredoc>     return (lst);
heredoc> }
heredoc> heredoc> int ft_lstsize2(t_envs *lst)
heredoc> {
heredoc>     t_envs *temp;
heredoc>     int i;
heredoc> heredoc>     temp = lst;
heredoc>     i = 0;
heredoc>     while (temp != NULL)
heredoc>     {
heredoc>         temp = temp->next;
heredoc>         i++;
heredoc>     }
heredoc>     return (i);
heredoc> }
heredoc> heredoc> heredoc> heredoc> heredoc> heredoc> heredoc> void ft_lstadd_back2(t_envs **lst, t_envs *new)
heredoc> {
heredoc>     t_envs *add;
heredoc> heredoc>     if (new)
heredoc>     {
heredoc>         if (!*lst)
heredoc>         {
heredoc>             *lst = new;
heredoc>             new->next = NULL;
heredoc>             return;
heredoc>         }
heredoc>         add = ft_lstlast(*lst);
heredoc>         add->next = new;
heredoc>         new->operator= 'c';
heredoc>         new->next = NULL;
heredoc>     }
heredoc> }
heredoc> heredoc> t_envs *ft_lstnew2(char *key)
heredoc> {
heredoc>     t_envs *newnode;
heredoc> heredoc>     newnode = malloc(sizeof(t_envs));
heredoc>     if (!newnode)
heredoc>         return (NULL);
heredoc>     newnode->key = strdup(key);
heredoc>     newnode->next = NULL;
heredoc>     newnode->operator= 'c';
heredoc>     return (newnode);
heredoc> }
heredoc> char *ft_strjoin(char const *s1, char const *s2)
heredoc> heredoc> {
heredoc>     char *new_str;
heredoc>     int i;
heredoc>     int j;
heredoc> heredoc>     if (!s1 && !s2)
heredoc>         return (0);
heredoc>     if (!s1)
heredoc>         return (strdup(s2));
heredoc>     if (!s2)
heredoc>         return (strdup(s1));
heredoc>     new_str = (char *)malloc(strlen(s1) + strlen(s2) + 1);
heredoc>     if (!new_str)
heredoc>         return (NULL);
heredoc>     i = 0;
heredoc>     while (s1[i] != '\0')
heredoc>     {
heredoc>         new_str[i] = s1[i];
heredoc>         i++;
heredoc>     }
heredoc>     j = 0;
heredoc>     while (s2[j] != '\0')
heredoc>         new_str[i++] = s2[j++];
heredoc>     new_str[i] = '\0';
heredoc>     return (new_str);
heredoc> }
heredoc> heredoc> void creat_node(t_envs **head, char *key)
heredoc> {
heredoc>     t_envs *new;
heredoc> heredoc>     if (*head == NULL)
heredoc>     {
heredoc>         *head = ft_lstnew2(key);
heredoc>     }
heredoc>     else
heredoc>     {
heredoc>         new = malloc(sizeof(t_envs));
heredoc>         new->key = strdup(key);
heredoc>         new->operator= 'c';
heredoc>         new->next = NULL;
heredoc>         ft_lstadd_back2(head, new);
heredoc>     }
heredoc> }
heredoc> void execute_at_root()
heredoc> {
heredoc>     char *root = getenv("HOME");
heredoc>     if (chdir(root) == -1)
heredoc>     {
heredoc>         perror("root file missed !");
heredoc>         exit(EXIT_FAILURE);
heredoc>     }
heredoc> }
heredoc> heredoc> char *get_key(char *str)
heredoc> {
heredoc>     int len = 0;
heredoc>     while (str[len] != '=')
heredoc>         len++;
heredoc>     char *new_str = (char *)malloc(sizeof(char) * len);
heredoc> heredoc>     strncpy(new_str, str, len);
heredoc> heredoc>     return new_str;
heredoc> }
heredoc> heredoc> int unset_env(t_envs *envs, char *key)
heredoc> {
heredoc>     t_envs *tmp;
heredoc> heredoc>     tmp = envs;
heredoc>     while (tmp)
heredoc>     {
heredoc>         char *k = get_key(tmp->key);
heredoc>         if (strcmp(k, key) == 0)
heredoc>         {
heredoc>             free(tmp->key);
heredoc>             free(tmp);
heredoc>             return 0;
heredoc>         }
heredoc>         tmp = tmp->next;
heredoc>     }
heredoc>     return -1;
heredoc> }
heredoc> heredoc> void handle_signal(int sig)
heredoc> {
heredoc>     if (sig == SIGINT)
heredoc>     {
heredoc>         printf("^C");
heredoc>         rl_clear_signals();
heredoc>     }
heredoc> }
heredoc> int main(int argc, char *argv[], char *env[])
heredoc> {
heredoc> heredoc>     (void)argc;
heredoc>     (void)argv;
heredoc>     // (void)env;
heredoc> heredoc>     t_envs *envs;
heredoc> heredoc>     envs = NULL;
heredoc> heredoc>     int i = 0;
heredoc> heredoc>     while (env[i] != NULL)
heredoc>     {
heredoc>         creat_node(&envs, env[i]);
heredoc>         i++;
heredoc>     }
heredoc> heredoc>     // printf("%s\n",env[0]);
heredoc> heredoc>     execute_at_root();
heredoc> heredoc>     if (access("./test.txt", F_OK) == -1)
heredoc>     {
heredoc>         printf("permission denied !\n");
heredoc>     }
heredoc>     else
heredoc>     {
heredoc>         printf("access authorized ");
heredoc>     }
heredoc> heredoc>     while (1)
heredoc>     {
heredoc>         // signal(SIGINT,handle_signal);
heredoc>         char cwd[1045];
heredoc>         if (getcwd(cwd, sizeof(cwd)) == NULL)
heredoc>         {
heredoc>             perror("getcwd");
heredoc>             exit(EXIT_FAILURE);
heredoc>         }
heredoc>         char *name = strrchr(cwd, '/');
heredoc>         char *root = getenv("HOME");
heredoc>         root = strrchr(root, '/');
heredoc>         if (strcmp(name + 1, root + 1) == 0)
heredoc>         {
heredoc> heredoc>             name = ft_strjoin("", "\033[33m ➜\033[0m ");
heredoc>         }
heredoc>         else
heredoc>         {
heredoc>             name = ft_strjoin(" \033[33m", name + 1);
heredoc>             name = ft_strjoin(name, "\33[0m\033[33m ➜\033[0m ");
heredoc>         }
heredoc>         char *cmd = readline(name);
heredoc> heredoc>         if (!cmd)
heredoc>         {
heredoc>             printf("\n");
heredoc>             break;
heredoc>         }
heredoc>         add_history(cmd);
heredoc>         if (strcmp(cmd, "exit") == 0)
heredoc>         {
heredoc>             printf("exit\n");
heredoc>             exit(EXIT_SUCCESS);
heredoc>         }
heredoc> heredoc>         pid_t pid = fork();
heredoc> heredoc>         if (pid == -1)
heredoc>         {
heredoc>             perror("fork error");
heredoc>             exit(EXIT_FAILURE);
heredoc>         }
heredoc>         else if (pid == 0)
heredoc>         {
heredoc>             excute_cmd(cmd, envs);
heredoc>         }
heredoc>         else
heredoc>         {
heredoc>             wait(NULL);
heredoc>         }
heredoc>     }
heredoc>     return (0);
heredoc> }
heredoc> #include "parsing.h"
t_envs *ft_lstlast2(t_envs *lst)
    if (!lst)
    while (lst->next != NULL)
        lst = lst->next;
    return (lst);
int ft_lstsize2(t_envs *lst)
    temp = lst;
    while (temp != NULL)
void ft_lstadd_back2(t_envs **lst, t_envs *new)
        if (!*lst)
            *lst = new;
        add = ft_lstlast(*lst);
t_envs *ft_lstnew2(char *key)
    newnode = malloc(sizeof(t_envs));
    new_str = (char *)malloc(strlen(s1) + strlen(s2) + 1);
    while (s1[i] != '\0')
    while (s2[j] != '\0')
        *head = ft_lstnew2(key);
    else
        new = malloc(sizeof(t_envs));
        ft_lstadd_back2(head, new);
        perror("root file missed !");
    int len = 0;
    while (str[len] != '=')
        len++;
    char *new_str = (char *)malloc(sizeof(char) * len);
    strncpy(new_str, str, len);
    while (tmp)
void handle_signal(int sig)
        rl_clear_signals();
    while (env[i] != NULL)
    else
    while (1)
        // signal(SIGINT,handle_signal);
        else
        char *cmd = readline(name);
        else if (pid == 0)
        else
